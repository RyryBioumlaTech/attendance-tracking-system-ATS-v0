<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attendance-Tracker</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style/bootstrap.min.css')}}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style/login.css')}}" media="screen">
</head>
<body>
    <canvas id="bg-net"></canvas>
    <form action="{{ url_for('login.login') }}" method="post">
        <h3>Connexion à votre compte</h3>

        <div>
            <label for="email">Adresse e-mail</label>
            <input type="email" id="email" name="email" placeholder="exemple@mail.com" required>
        </div>

        <div>
            <label for="password">Mot de passe</label>
            <input type="password" name="password" id="password" placeholder="••••••••" required>
        </div>

        <div>
            <button type="submit">Se connecter</button>
        </div>
    </form>

    
    <script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js')}}" ></script>
    <script>
        (() => {
        const canvas = document.getElementById('bg-net');
        const ctx = canvas.getContext('2d');

        // ====== Paramètres à tweaker ======
        const CONFIG = {
            density: 0.00018,      // nombre de particules par pixel (≈ 0.00012–0.00025)
            maxSpeed: 0.6,         // vitesse max (px/frame)
            radius: 2.0,           // rayon des points
            linkDist: 120,         // distance max pour relier (px)
            lineWidth: 1,          // épaisseur des lignes
            dotColor: 'rgba(255,255,255,0.8)',
            lineColor: 'rgba(255,255,255,0.15)',
            mouseInfluence: 160,   // distance d'influence de la souris (0 pour désactiver)
            bounce: true           // rebondir sur les bords
        };

        let particles = [];
        let w = 0, h = 0, dpr = Math.max(1, window.devicePixelRatio || 1);
        const mouse = { x: null, y: null, active: false };

        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width  = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            // recalculer le nombre de particules selon la surface
            const targetCount = Math.round(w * h * CONFIG.density);
            adjustParticleCount(targetCount);
        }

        function rand(min, max) { return Math.random() * (max - min) + min; }

        function createParticle() {
            const angle = Math.random() * Math.PI * 2;
            const speed = rand(0.2, CONFIG.maxSpeed);
            return {
            x: Math.random() * w,
            y: Math.random() * h,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
            };
        }

        function adjustParticleCount(target) {
            if (particles.length < target) {
            for (let i = particles.length; i < target; i++) particles.push(createParticle());
            } else if (particles.length > target) {
            particles.length = target;
            }
        }

        function step() {
            ctx.clearRect(0, 0, w, h);

            // Mise à jour positions + dessin points
            ctx.fillStyle = CONFIG.dotColor;
            for (let p of particles) {
            p.x += p.vx; p.y += p.vy;

            if (CONFIG.bounce) {
                if (p.x <= 0 || p.x >= w) p.vx *= -1;
                if (p.y <= 0 || p.y >= h) p.vy *= -1;
                // clamp pour rester à l'écran
                if (p.x < 0) p.x = 0; else if (p.x > w) p.x = w;
                if (p.y < 0) p.y = 0; else if (p.y > h) p.y = h;
            } else {
                // wrap-around
                if (p.x < 0) p.x = w; else if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h; else if (p.y > h) p.y = 0;
            }

            // léger aimant vers la souris
            if (CONFIG.mouseInfluence > 0 && mouse.active) {
                const dx = p.x - mouse.x, dy = p.y - mouse.y;
                const d2 = dx*dx + dy*dy;
                if (d2 < CONFIG.mouseInfluence * CONFIG.mouseInfluence && d2 > 0.0001) {
                const d = Math.sqrt(d2);
                const force = (CONFIG.mouseInfluence - d) / CONFIG.mouseInfluence * 0.03; // 0.0–0.03
                p.vx += (dx / d) * force;
                p.vy += (dy / d) * force;
                }
            }

            // dessiner le point
            ctx.beginPath();
            ctx.arc(p.x, p.y, CONFIG.radius, 0, Math.PI * 2);
            ctx.fill();
            }

            // Lignes entre particules proches (optimisé par quadrillage simple)
            ctx.lineWidth = CONFIG.lineWidth;
            ctx.strokeStyle = CONFIG.lineColor;

            // Partitionner l'espace en cellules pour limiter les comparaisons
            const cellSize = CONFIG.linkDist;
            const cols = Math.ceil(w / cellSize);
            const rows = Math.ceil(h / cellSize);
            const grid = Array.from({ length: cols * rows }, () => []);
            for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const cx = Math.min(cols - 1, Math.max(0, (p.x / cellSize) | 0));
            const cy = Math.min(rows - 1, Math.max(0, (p.y / cellSize) | 0));
            grid[cy * cols + cx].push(i);
            }

            function neighbors(cx, cy) {
            const out = [];
            for (let y = cy - 1; y <= cy + 1; y++) {
                if (y < 0 || y >= rows) continue;
                for (let x = cx - 1; x <= cx + 1; x++) {
                if (x < 0 || x >= cols) continue;
                out.push(grid[y * cols + x]);
                }
            }
            return out.flat();
            }

            for (let cy = 0; cy < rows; cy++) {
            for (let cx = 0; cx < cols; cx++) {
                const idxs = grid[cy * cols + cx];
                const neigh = neighbors(cx, cy);
                for (let i = 0; i < idxs.length; i++) {
                const a = particles[idxs[i]];
                for (let j = 0; j < neigh.length; j++) {
                    const b = particles[neigh[j]];
                    if (a === b) continue;
                    const dx = a.x - b.x, dy = a.y - b.y;
                    const d2 = dx*dx + dy*dy;
                    if (d2 <= CONFIG.linkDist * CONFIG.linkDist) {
                    const alpha = 1 - (Math.sqrt(d2) / CONFIG.linkDist);
                    ctx.globalAlpha = Math.min(0.6, alpha); // fondu selon distance
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    }
                }
                }
            }
            }
            requestAnimationFrame(step);
        }

        // Souris / tactile
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true;
        }, { passive: true });
        window.addEventListener('mouseleave', () => { mouse.active = false; });
        window.addEventListener('touchstart', e => {
            const t = e.touches[0]; mouse.x = t.clientX; mouse.y = t.clientY; mouse.active = true;
        }, { passive: true });
        window.addEventListener('touchmove', e => {
            const t = e.touches[0]; mouse.x = t.clientX; mouse.y = t.clientY; mouse.active = true;
        }, { passive: true });
        window.addEventListener('touchend', () => { mouse.active = false; });
        // Init
        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(step);
        })();
    </script>
</body>
</html>